#!/bin/bash 
# NOT POSIX, AT ALL. TODO: Make this not suck. Create a bash fork that does not have any of the BASH exclusive "features" and is 100% POSIX and ISO C.

# ANSI color codes
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Directories, files, etc. NOTE: Not consistent. TODO: Enhance readability, simplify variables.
INSTALL_DIR=${HOME}/.local/share/bin
TEMP_DIR=/tmp
CACHE_FILE=${TMPDIR:-${TEMP_DIR}}/bdl_install-less_bins_cached
SYSTEM_ARCH=$(uname -m)

# Display a spinner loader with default colors
spinner() {
    if [ -z "$COOLSPINNER" ]; then
        COOLSPINNER='|/~\\'
    fi

    if [ -z "$COOLSPINNER_COLOR" ]; then
        COOLSPINNER_COLOR='\033[0m'
    fi

    if [ -z "$COOLSPINNER_DELAY" ]; then
        COOLSPINNER_DELAY=0.1
    fi

    len=$(printf "%s" "$COOLSPINNER" | wc -c | awk '{print $1}')
    trap 'printf "\033[?25h"; exit' INT

    while true; do
        i=1
        while [ "$i" -le "$len" ]; do
            char=$(printf "%s" "$COOLSPINNER" | cut -c "$i")
            if [ -n "$COOLSPINNER_COLOR" ]; then
                printf "%b%s%b" "$COOLSPINNER_COLOR" "$char" "\033[0m"
            else
                printf "%s" "$char"
            fi
            sleep "$COOLSPINNER_DELAY"
            printf "\b"
            i=$((i + 1))
        done
    done
}

# Function to display colored output
print_color() {
    printf "%b%s%b\\n" "$1" "$2" "$NC"
}

fetch_binary() {
    PACKAGE_NAME="$1"
    INSTALL_DIR="$2"
    DESTINATION="${3:-$PACKAGE_NAME}" # Default DESTINATION

    source_url=$(find_url "$PACKAGE_NAME")

    if [ -z "$source_url" ]; then
        print_color "$YELLOW" "Source URL not found for '$PACKAGE_NAME'."
        return 1
    fi

    mkdir -p "$INSTALL_DIR"  # Ensure the directory exists

    # Start spinner in the background
    spinner & spinner_pid=$!

    if eval "$FETCHER -qO \"$INSTALL_DIR/$DESTINATION\" \"$source_url\"" && chmod +x "$INSTALL_DIR/$DESTINATION"; then
        # Kill the spinner after download completes
        kill "$spinner_pid" >/dev/null 2>&1

        # Clear the line
        printf "\033[2K\r"

        print_color "$GREEN" "Fetched binary successfully."

        return 0
    else
        # Kill the spinner if download fails
        kill "$spinner_pid" >/dev/null 2>&1

        # Clear the line
        printf "\033[2K\r"

        print_color "$YELLOW" "Failed to fetch binary."

        return 1
    fi
}

# Function to retrieve cached file location
return_cached_file() {
    PACKAGE_NAME="$1"

    if [ -f "$CACHE_FILE" ] && grep -q "^$PACKAGE_NAME " "$CACHE_FILE"; then
        cached_location=$(grep -E "^$PACKAGE_NAME " "$CACHE_FILE" | awk '{ print $2 }')
        if [ -n "$cached_location" ]; then
            printf "%s\n" "$cached_location"
            return 0
        fi
    fi

    return 1
}

# Function to clean the cache (limit 40 programs)
clean_cache() {
    if [ -f "$CACHE_FILE" ]; then
        # Remove duplicate entries in the cache
        awk '!seen[$0]++' "$CACHE_FILE" > temp.txt
        mv temp.txt "$CACHE_FILE"

        # Remove non-existent files from the cache
        while read -r line; do
            cached_package=$(echo "$line" | awk '{print $1}')
            cached_file=$(echo "$line" | awk '{print $2}')
            if [ ! -f "$TEMP_DIR/$cached_file" ] || [ "$cached_package" != "$(echo "$cached_file" | cut -d'-' -f 1 | cut -d'_' -f 2-)" ]; then
                sed -i "/$cached_file/d" "$CACHE_FILE"
            fi
        done < "$CACHE_FILE"
    fi
}

# Function to run from cache or fetch if not found
run_from_cache() {
    PACKAGE_NAME="$1"
    cached_location=$(return_cached_file "$PACKAGE_NAME")

    if [ -n "$cached_location" ] && [ -x "$TEMP_DIR/$cached_location" ]; then
        printf "%bRunning '%s' from cache...%b\n" "$GREEN" "$PACKAGE_NAME" "$NC"
        clean_cache
        "$TEMP_DIR/$cached_location" "${@:2}" # Pass additional parameters as flags
        return 0
    else
        new_cached_location="bdl_$PACKAGE_NAME-$(date +'%s')"
        if fetch_binary "$PACKAGE_NAME" "$TEMP_DIR" "$new_cached_location"; then
            echo "$PACKAGE_NAME $new_cached_location" >> "$CACHE_FILE" # Update cache with the fetched binary
            clean_cache # Clean the cache
            "$TEMP_DIR/$new_cached_location" "${@:2}" # Execute the fetched binary
            return 0
        else
            printf "%bFailed to fetch binary '%s'.%b\n" "$YELLOW" "$PACKAGE_NAME" "$NC"
            return 1
        fi
    fi
}

install_binary() {
    PACKAGE_NAME="$1"
    TEMP_DIR="/tmp" # Change this to your preferred installation directory

    # Check if the package name is empty
    if [ -z "$PACKAGE_NAME" ]; then
        print_color "$YELLOW" "No package name provided."
        return
    fi

    # Check if the binary is already installed in the INSTALL_DIR
    if [ -f "$INSTALL_DIR/$PACKAGE_NAME" ]; then
        print_color "$YELLOW" "The requested binary is already at: $INSTALL_DIR/$PACKAGE_NAME. Will not perform an install."
        return
    fi

    # Get the cached location of the package
    cached_location=$(return_cached_file "$PACKAGE_NAME")

    if [ -n "$cached_location" ] && [ -x "$TEMP_DIR/$cached_location" ]; then
        print_color "$GREEN" "Installing '$PACKAGE_NAME' from cache..."
        mv "$TEMP_DIR/$cached_location" "$INSTALL_DIR/$PACKAGE_NAME"
        clean_cache # Remove duplicates and non-existent files from the cache
        return
    fi

    # Fetch the binary if it's not found in the installation directory or cache
    fetch_binary "$PACKAGE_NAME" "$INSTALL_DIR" && print_color "$GREEN" "OK: $INSTALL_DIR/$PACKAGE_NAME"
    clean_cache # Remove duplicates and non-existent files from the cache
}

# Function to remove an installed package
remove_package() {
    PACKAGE_NAME="$1"
    PACKAGE_LOCATION="$INSTALL_DIR/$PACKAGE_NAME"

    if [ -f "$PACKAGE_LOCATION" ]; then
        rm "$PACKAGE_LOCATION" && print_color "$GREEN" "Package '$PACKAGE_NAME' removed."
    else
        print_color "$YELLOW" "Package '$PACKAGE_NAME' is not installed."
    fi
}

# Function to retrieve package source URL
find_url() {
    PACKAGE_NAME="$1"
    METADATA_URL="https://raw.githubusercontent.com/metis-os/hysp-pkgs/main/data/metadata.json"
    SOURCE_URL=$(curl -s "$METADATA_URL" | jq -r --arg pname "$PACKAGE_NAME" --arg sysarch "$SYSTEM_ARCH" \
        '.packages[] | select(.name == $pname and .architecture == $sysarch) | .source')
    # Check if source URL is empty
    if [ -z "$SOURCE_URL" ]; then
        LIST_PACKAGES_RESULT=$(list_packages | grep "^$PACKAGE_NAME$")
        if [ -n "$LIST_PACKAGES_RESULT" ]; then
            SOURCE_URL="https://raw.githubusercontent.com/Azathothas/Toolpacks/main/$SYSTEM_ARCH/$PACKAGE_NAME"
        fi
    fi
    # Check if the SOURCE_URL returns 404
    if [ -n "$SOURCE_URL" ]; then
        if ! curl --output /dev/null --silent --head --fail "$SOURCE_URL"; then
            SOURCE_URL="https://raw.githubusercontent.com/Azathothas/Static-Binaries/main/baseutils/$SYSTEM_ARCH/$PACKAGE_NAME"
        fi
    fi
    printf '%s\n' "$SOURCE_URL"
}

# Function to show detailed package information with color
show_package_info() {
    PACKAGE_NAME="$1"
    METADATA_URL="https://raw.githubusercontent.com/metis-os/hysp-pkgs/main/data/metadata.json"

    # Start spinner in the background & capture its PID.
    spinner & spinner_pid=$!

    PACKAGE_INFO=$(curl -s "$METADATA_URL" | jq --arg pname "$PACKAGE_NAME" --arg sysarch "$SYSTEM_ARCH" \
        '.packages[] | select(.name == $pname and .architecture == $sysarch) | {description, name, version, updated, size, sha, source}')

    if [ -z "$PACKAGE_INFO" ]; then
        # Kill the spinner if download fails
        kill "$spinner_pid" >/dev/null 2>&1

        # Clear the line
        printf "\033[2K\r"

        # Print error.
        print_color "$YELLOW" "Package '$PACKAGE_NAME' not found."
    else
        # Kill the spinner if download succeeds
        kill "$spinner_pid" >/dev/null 2>&1

        # Clear the line
        printf "\033[2K\r"

        # SUCCESS: Print info in JSON.
        print_color "$GREEN" "$PACKAGE_INFO"
    fi
}

fSearch() {
    SEARCH_TERM="$1"
    METADATA_URL="https://raw.githubusercontent.com/metis-os/hysp-pkgs/main/data/metadata.json"

    # Fetch metadata
    METADATA=$(curl -s "$METADATA_URL")

    # Check if metadata retrieval failed
    if [ -z "$METADATA" ]; then
        printf "Failed to fetch package information.\n"
        return
    fi

    # Get terminal width using tput if available, otherwise set a default width
    TERMINAL_WIDTH=$(tput cols 2>/dev/null || echo 80)

    # Function to truncate text and append "..."
    truncate_text() {
        text="$1"
        max_length="$2"
        if [ ${#text} -gt "$max_length" ]; then
            printf "%s..." "${text:0:max_length-3}"
        else
            printf "%s" "$text"
        fi
    }

    # Filter packages based on the search term and format output
    SEARCH_RESULTS=$(echo "$METADATA" | jq -r --arg sterm "$SEARCH_TERM" \
        '.packages[] | select(.name + .description | test($sterm; "i")) | [.name, .description] | @tsv')

    if [ -z "$SEARCH_RESULTS" ]; then
        printf "No matching packages found for '%s'.\n" "$SEARCH_TERM"
    else
        # Array to store unique package names
        unique_names=()

        # Loop through each line of SEARCH_RESULTS
        while IFS= read -r line; do
            # Extract package name from the line
            PACKAGE_NAME=$(echo "$line" | awk '{print $1}')

            # Check if the name has already been processed
            if ! printf '%s\n' "${unique_names[@]}" | grep -q "$PACKAGE_NAME"; then
                unique_names+=("$PACKAGE_NAME")  # Add the name to the list of processed names

                # Extract package description from the line
                PACKAGE_DESC=$(echo "$line" | cut -f2-)

                PACKAGE_STATUS=""
                if [ -f "${INSTALL_DIR}/${PACKAGE_NAME}" ]; then
                    PACKAGE_STATUS="[*]"  # Package is installed
                else
                    PACKAGE_STATUS="[-]"  # Package is not installed
                fi

                # Truncate description if it exceeds a certain length and append "..."
                TRUNCATED_DESC=$(truncate_text "$PACKAGE_DESC" "$TERMINAL_WIDTH")

                printf "%s %s\t%s\n" "$PACKAGE_STATUS" "$PACKAGE_NAME" "$TRUNCATED_DESC"
            fi
        done
    fi
}

# Function to list all possible packages
list_packages() {
    spinner & spinner_pid=$!
    packages=$(
        {
            curl -qfsSL "https://api.github.com/repos/Azathothas/Toolpacks/contents/$SYSTEM_ARCH/" && \
            curl -qfsSL "https://api.github.com/repos/Azathothas/Static-Binaries/contents/baseutils/$SYSTEM_ARCH"
        } | jq -r '.[].name' | sort | uniq | awk '!/^[[:upper:]]+$|^.*\..*$|^BLAKE3SUM$|^SHA256SUM$/{print}')
    kill "$spinner_pid" >/dev/null 2>&1
    printf "\033[2K\r%s\n" "$packages"
}

bootstrap_binary() {
    PACKAGE_NAME="$1"
    DESTINATION="$TEMP_DIR/bdl_bootstrap/$PACKAGE_NAME"
    TOOLPACK="https://raw.githubusercontent.com/Azathothas/Toolpacks/main/$SYSTEM_ARCH"
    BASEU="https://raw.githubusercontent.com/Azathothas/Static-Binaries/main/baseutils/$SYSTEM_ARCH"

    mkdir -p "$TEMP_DIR/bdl_bootstrap"

    if [ -f "$DESTINATION" ]; then
        printf "Using previously bootstrapped binary for $PACKAGE_NAME at $DESTINATION\n"
        chmod +x "$DESTINATION"
    else
        if [ -n "$BASE" ]; then
            source_url="$BASEU"
        else
            source_url="$TOOLPACK"
        fi

        determine_fetcher

        # Start spinner in the background
        COOLSPINNER_COLOR='\033[92m'
        spinner & spinner_pid=$!

        if [ "$FETCHER" = "curl" ]; then
            "$FETCHER" -o "$DESTINATION" "$source_url/$PACKAGE_NAME" >/dev/null 2>&1 &&
            kill "$spinner_pid" >/dev/null 2>&1 &&
            printf "\033[2K\r" &&
            chmod +x "$DESTINATION" ||
            print_color "Failed to fetch $PACKAGE_NAME." "yellow"
        elif [ "$FETCHER" = "wget" ]; then
            "$FETCHER" -O "$DESTINATION" "$source_url/$PACKAGE_NAME" >/dev/null 2>&1 &&
            kill "$spinner_pid" >/dev/null 2>&1 &&
            printf "\033[2K\r" &&
            chmod +x "$DESTINATION" ||
            print_color "Failed to fetch $PACKAGE_NAME." "yellow"
        else
            print_color "Neither curl nor wget could be found. Cannot proceed with bootstrapping." "yellow"
        fi
    fi
}

bootstrap() {
    # Define a helper function to determine which fetcher tool (curl or wget) should be used for bootstrapping
    determine_fetcher() {
        if command -v wget >/dev/null 2>&1 || command -v curl >/dev/null 2>&1; then
            if command -v wget >/dev/null 2>&1; then
                FETCHER="wget"
            else
                FETCHER="curl"
            fi

            if [ "$FETCHER" = "curl" ] && ! command -v curl >/dev/null 2>&1; then
                FETCHER_TO_BOOTSTRAP="curl"
            elif [ "$FETCHER" = "wget" ] && ! command -v wget >/dev/null 2>&1; then
                FETCHER_TO_BOOTSTRAP="wget"
            fi
        else
            printf "Neither curl nor wget found. Cannot proceed with bootstrapping.\n" && return 1
        fi
    }

    determine_fetcher

    export PATH="/tmp/bdl_bootstrap:$PATH"

    if [ -n "$FETCHER" ]; then
        if [ "$FETCHER" != "curl" ] && ! command -v curl >/dev/null 2>&1; then
            printf "${YELLOW}$FETCHER_TO_BOOTSTRAP is not installed. Bootstrapping...${NC}\n"
            bootstrap_binary "$FETCHER_TO_BOOTSTRAP"
        fi

        if ! command -v jq >/dev/null 2>&1; then
            printf "${YELLOW}jq is not installed. Bootstrapping...${NC}\n"
            bootstrap_binary "jq"
        fi

        if ! command -v awk >/dev/null 2>&1; then
            printf "${YELLOW}awk is not installed. Bootstrapping...${NC}\n"
            BASE="true" bootstrap_binary "awk"
        fi
    fi
}

bootstrap

case $1 in
    run)
        run_from_cache "$2" "${@:3}"
        ;;
    install)
        install_binary "$2"
        ;;
    remove)
        remove_package "$2"
        ;;
    search)
        fSearch "$2"
        ;;
    info)
        show_package_info "$2"
        ;;
    list)
        list_packages
        ;;
    tldr)
        run_from_cache tldr "${@:2}"
        ;;
    *)
        printf 'Usage: %s {run|install|remove|search|info|list|tldr} <PACKAGE_NAME>\n' "$0"
        exit 1
        ;;
esac

exit 0
