#!/bin/sh

# ANSI color codes
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Directories, files, etc. NOTE: Not consistent. TODO: Enhance readability, simplify variables.
INSTALL_DIR=${HOME}/.local/share/bin
TEMP_DIR=/tmp
CACHE_FILE=${TMPDIR:-${TEMP_DIR}}/bdl_install-less_bins_cached
SYSTEM_ARCH=$(uname -m)

# Display a spinner loader with default colors
spinner() {
    if [ -z "$COOLSPINNER" ]; then
        COOLSPINNER='|/~\\'
    fi

    if [ -z "$COOLSPINNER_COLOR" ]; then
        COOLSPINNER_COLOR='\033[0m'
    fi

    if [ -z "$COOLSPINNER_DELAY" ]; then
        COOLSPINNER_DELAY=0.1
    fi

    len=$(printf "%s" "$COOLSPINNER" | wc -c | awk '{print $1}')
    trap 'printf "\033[?25h"; exit' INT

    while true; do
        i=1
        while [ "$i" -le "$len" ]; do
            char=$(printf "%s" "$COOLSPINNER" | cut -c "$i")
            if [ -n "$COOLSPINNER_COLOR" ]; then
                printf "%b%s%b" "$COOLSPINNER_COLOR" "$char" "\033[0m"
            else
                printf "%s" "$char"
            fi
            sleep "$COOLSPINNER_DELAY"
            printf "\b"
            i=$((i + 1))
        done
    done
}

# Function to display colored output
print_color() {
    printf "%b%s%b\\n" "$1" "$2" "$NC"
}

fetch_binary() {
    PACKAGE_NAME="$1"
    INSTALL_DIR="$2"
    DESTINATION="${3:-$PACKAGE_NAME}" # Default DESTINATION

    source_url=$(find_url "$PACKAGE_NAME")

    if [ -z "$source_url" ]; then
        print_color "$YELLOW" "Source URL not found for '$PACKAGE_NAME'."
        return 1
    fi

    mkdir -p "$INSTALL_DIR"  # Ensure the directory exists

    # Start spinner in the background
    spinner & spinner_pid=$!

    if wget -O "$INSTALL_DIR/$DESTINATION" "$source_url" && chmod +x "$INSTALL_DIR/$DESTINATION"; then
        # Kill the spinner after download completes
        kill "$spinner_pid" >/dev/null 2>&1
        # Move the cursor to the beginning of the line and clear the line
        printf "\033[2K\r"
        print_color "$GREEN" "Fetched binary successfully."
        return 0
    else
        # Kill the spinner if download fails
        kill "$spinner_pid" >/dev/null 2>&1
        # Move the cursor to the beginning of the line and clear the line
        printf "\033[2K\r"
        print_color "$YELLOW" "Failed to fetch binary."
        return 1
    fi
}

# Function to check cached file and return its location
return_cached_file() {
    PACKAGE_NAME="$1"

    if [ -f "$CACHE_FILE" ] && grep -q "^$PACKAGE_NAME " "$CACHE_FILE"; then
        cached_location=$(awk -v pname="$PACKAGE_NAME" '$1 == pname { print $2 }' "$CACHE_FILE")
        if [ -n "$cached_location" ]; then
            printf "%s\n" "$cached_location"
            return 0
        fi
    fi
    return 1
}

# Function to run from cache or fetch if not found
run_from_cache() {
    PACKAGE_NAME="$1"
    TEMP_DIR="/tmp" # Change this to your preferred installation directory
    TEMP_NAME="bdl_$PACKAGE_NAME-$(date +'%s')"
    cached_location=$(return_cached_file "$PACKAGE_NAME")
    if [ -n "$cached_location" ] && [ -x "$TEMP_DIR/$cached_location" ]; then
        print_color "$GREEN" "Running '$PACKAGE_NAME' from cache..."
        "$TEMP_DIR/$cached_location" "${@:2}" # Pass additional parameters as flags
        return 0
    else
        if fetch_binary "$PACKAGE_NAME" "$TEMP_DIR" "$TEMP_NAME"; then
            echo "$PACKAGE_NAME $TEMP_NAME" >> "$CACHE_FILE"
            clean_cache
            "$TEMP_DIR/$TEMP_NAME" "${@:2}" # Pass additional parameters as flags
            return 0
        else
            print_color "$YELLOW" "Failed to fetch binary '$PACKAGE_NAME'."
            return 1
        fi
    fi
}

# Function to clean the cache (limit 40 programs)
clean_cache() {
    if [ -f "$CACHE_FILE" ]; then
        lines=$(wc -l < "$CACHE_FILE")
        if [ "$lines" -gt 40 ]; then
            sed -i '1,40d' "$CACHE_FILE"
        fi
    fi
}

install_binary() {
    PACKAGE_NAME="$1"
    # Check if the binary is already installed in the INSTALL_DIR
    if [ -f "$INSTALL_DIR/$PACKAGE_NAME" ]; then
        print_color "$YELLOW" "The requested binary is already at: $INSTALL_DIR/$PACKAGE_NAME. Will not perform an install."
        return
    fi
    # Use return_cached_file to check for the binary in the cache
    cached_location=$(return_cached_file "$PACKAGE_NAME")
    if [ $? -eq 0 ] && [ -x "$TEMP_DIR/$cached_location" ]; then
        print_color "$GREEN" "Installing '$PACKAGE_NAME' from cache..."
        fetch_binary "$PACKAGE_NAME" "$INSTALL_DIR" && print_color "$GREEN" "OK: $INSTALL_DIR/$PACKAGE_NAME"
        mv "$TEMP_DIR/$cached_location" "$INSTALL_DIR/$PACKAGE_NAME"
        return
    fi
    if [ ! -f "$INSTALL_DIR/$PACKAGE_NAME" ]; then
        fetch_binary "$PACKAGE_NAME" "$INSTALL_DIR" && print_color "$GREEN" "OK: $INSTALL_DIR/$PACKAGE_NAME"
    fi
}

# Function to remove an installed package
remove_package() {
    PACKAGE_NAME="$1"
    PACKAGE_LOCATION="$INSTALL_DIR/$PACKAGE_NAME"

    if [ -f "$PACKAGE_LOCATION" ]; then
        rm "$PACKAGE_LOCATION" && print_color "$GREEN" "Package '$PACKAGE_NAME' removed."
    else
        print_color "$YELLOW" "Package '$PACKAGE_NAME' is not installed."
    fi
}

# Function to retrieve package source URL
find_url() {
    PACKAGE_NAME="$1"
    METADATA_URL="https://raw.githubusercontent.com/metis-os/hysp-pkgs/main/data/metadata.json"
    SOURCE_URL=$(curl -s "$METADATA_URL" | jq -r --arg pname "$PACKAGE_NAME" --arg sysarch "$SYSTEM_ARCH" \
        '.packages[] | select(.name == $pname and .architecture == $sysarch) | .source')
    # Check if source URL is empty
    if [ -z "$SOURCE_URL" ]; then
        LIST_PACKAGES_RESULT=$(list_packages | grep "^$PACKAGE_NAME$")
        if [ -n "$LIST_PACKAGES_RESULT" ]; then
            SOURCE_URL="https://raw.githubusercontent.com/Azathothas/Toolpacks/main/$SYSTEM_ARCH/$PACKAGE_NAME"
        fi
    fi
    # Check if the SOURCE_URL returns 404
    if [ -n "$SOURCE_URL" ]; then
        if ! curl --output /dev/null --silent --head --fail "$SOURCE_URL"; then
            SOURCE_URL="https://raw.githubusercontent.com/Azathothas/Static-Binaries/main/baseutils/$SYSTEM_ARCH/$PACKAGE_NAME"
        fi
    fi
    printf '%s\n' "$SOURCE_URL"
}

# Function to show detailed package information with color
show_package_info() {
    PACKAGE_NAME="$1"
    METADATA_URL="https://raw.githubusercontent.com/metis-os/hysp-pkgs/main/data/metadata.json"

    # Start spinner in the background & capture its PID.
    spinner & spinner_pid=$!

    PACKAGE_INFO=$(curl -s "$METADATA_URL" | jq --arg pname "$PACKAGE_NAME" --arg sysarch "$SYSTEM_ARCH" \
        '.packages[] | select(.name == $pname and .architecture == $sysarch) | {description, name, version, updated, size, sha, source}')

    if [ -z "$PACKAGE_INFO" ]; then
        # Kill the spinner if download fails
        kill "$spinner_pid" >/dev/null 2>&1
        # Move the cursor to the beginning of the line and clear the line
        printf "\033[2K\r"
        # Print error.
        print_color "$YELLOW" "Package '$PACKAGE_NAME' not found."
    else
        # Kill the spinner if download fails
        kill "$spinner_pid" >/dev/null 2>&1
        # Move the cursor to the beginning of the line and clear the line
        printf "\033[2K\r"
        # SUCCESS: Print info in JSON.
        print_color "$GREEN" "$PACKAGE_INFO"
    fi
}

fSearch() {
    SEARCH_TERM="$1"
    METADATA_URL="https://raw.githubusercontent.com/metis-os/hysp-pkgs/main/data/metadata.json"

    # Fetch metadata
    METADATA=$(curl -s "$METADATA_URL")

    # Check if metadata retrieval failed
    if [ -z "$METADATA" ]; then
        printf "Failed to fetch package information.\n"
        return
    fi

    # Get terminal width using tput if available, otherwise set a default width
    TERMINAL_WIDTH=$(tput cols 2>/dev/null || echo 80)

    # Function to truncate text and append "..."
    truncate_text() {
        text="$1"
        max_length="$2"
        if [ ${#text} -gt "$max_length" ]; then
            printf "%s..." "${text:0:max_length-3}"
        else
            printf "%s" "$text"
        fi
    }

    # Filter packages based on the search term and format output
    SEARCH_RESULTS=$(printf '%s\n' "$METADATA" | jq -r --arg sterm "$SEARCH_TERM" \
        '.packages[] | select(.name + .description | test($sterm; "i")) | [.name, .description] | @tsv')

    if [ -z "$SEARCH_RESULTS" ]; then
        printf "No matching packages found for '%s'.\n" "$SEARCH_TERM"
    else
        # Array to store unique package names
        unique_names=()

        # Loop through each line of SEARCH_RESULTS
        printf "%s\n" "$SEARCH_RESULTS" | while IFS= read -r line; do
            # Extract package name from the line
            PACKAGE_NAME=$(printf "%s" "$line" | awk '{print $1}')

            # Check if the name has already been processed
            if ! printf "%s\n" "${unique_names[@]}" | grep -q "^$PACKAGE_NAME$"; then
                unique_names+=("$PACKAGE_NAME")  # Add the name to the list of processed names

                # Extract package description from the line
                PACKAGE_DESC=$(printf "%s" "$line" | cut -f2-)

                PACKAGE_STATUS=""
                if [ -f "${INSTALL_DIR}/${PACKAGE_NAME}" ]; then
                    PACKAGE_STATUS="[*]"  # Package is installed
                else
                    PACKAGE_STATUS="[-]"  # Package is not installed
                fi

                # Truncate description if it exceeds a certain length and append "..."
                TRUNCATED_DESC=$(truncate_text "$PACKAGE_DESC" "$TERMINAL_WIDTH")

                printf "%s %s\t%s\n" "$PACKAGE_STATUS" "$PACKAGE_NAME" "$TRUNCATED_DESC"
            fi
        done | sort -k2
    fi
}

# Function to list all possible packages
list_packages() {
    spinner & spinner_pid=$!
    packages=$( {
        curl -qfsSL "https://api.github.com/repos/Azathothas/Toolpacks/contents/$SYSTEM_ARCH/" && curl -qfsSL "https://api.github.com/repos/Azathothas/Static-Binaries/contents/baseutils/$SYSTEM_ARCH"
    } | jq -r '.[].name' | sort | uniq | awk '!/^[[:upper:]]+$|^.*\..*$|^BLAKE3SUM$|^SHA256SUM$/{print}')
    kill "$spinner_pid" >/dev/null 2>&1
    printf "\033[2K\r%s\n" "$packages"
}

bootstrap() {
    determine_fetcher() {
        if command -v wget >/dev/null 2>&1; then
            FETCHER="wget"
            if ! command -v curl >/dev/null 2>&1; then
                FETCHER_TO_BOOTSTRAP="curl"
                return 0
            fi
        elif command -v curl >/dev/null 2>&1; then
            FETCHER="curl"
            if ! command -v wget >/dev/null 2>&1; then
                FETCHER_TO_BOOTSTRAP="wget"
                return 0
            fi
        else
            printf "Neither curl nor wget found. Cannot proceed with bootstrapping.\n" && return 1
        fi
    }
    bootstrap_binary() {
        PACKAGE_NAME="$1"
        DESTINATION="$TEMP_DIR/bdl_bootstrap/$PACKAGE_NAME"
        TOOLPACK="https://raw.githubusercontent.com/Azathothas/Toolpacks/main/$SYSTEM_ARCH"
        BASEU="https://raw.githubusercontent.com/Azathothas/Static-Binaries/main/baseutils/$SYSTEM_ARCH"
        mkdir -p "$TEMP_DIR/bdl_bootstrap"

        if [ -f "$DESTINATION" ]; then
            printf "Using previously bootstrapped binary. For $PACKAGE_NAME at $DESTINATION \n"
            chmod +x "$DESTINATION"
        else
            if [ -n "$BASE" ]; then
                source_url="$BASEU"
            else
                source_url="$TOOLPACK"
            fi

            determine_fetcher

            # Start spinner in the background
            COOLSPINNER_COLOR='\033[92m' &&
            spinner & spinner_pid=$!
            if [ "$FETCHER" = "curl" ]; then
                "$FETCHER" -o "$DESTINATION" "$source_url/$PACKAGE_NAME" &&
                kill "$spinner_pid" >/dev/null 2>&1 &&
                printf "\033[2K\r" &&
                chmod +x "$DESTINATION" ||
                { printf "${YELLOW}Failed to fetch $PACKAGE_NAME.${NC}\n"; }
            elif [ "$FETCHER" = "wget" ]; then
                "$FETCHER" -O "$DESTINATION" "$source_url/$PACKAGE_NAME" &&
                kill "$spinner_pid" >/dev/null 2>&1 &&
                printf "\033[2K\r" &&
                chmod +x "$DESTINATION" ||
                { printf "${YELLOW}Failed to fetch $PACKAGE_NAME.${NC}\n"; }
            else
                printf "${YELLOW}Neither curl nor wget could be found. Cannot proceed with bootstrapping.${NC}\n"
            fi
        fi
    }
    determine_fetcher
    export PATH="/tmp/bdl_bootstrap:$PATH"
    if [ -n "$FETCHER" ]; then
        if [ "$FETCHER" != "curl" ] && ! command -v curl >/dev/null 2>&1; then
            printf "${YELLOW}$FETCHER_TO_BOOTSTRAP is not installed. Bootstrapping...${NC}\n"
            bootstrap_binary "$FETCHER_TO_BOOTSTRAP"
        fi

        if ! command -v jq >/dev/null 2>&1; then
            printf "${YELLOW}jq is not installed. Bootstrapping...${NC}\n"
            bootstrap_binary "jq"
        fi

        if ! command -v awk >/dev/null 2>&1; then
            printf "${YELLOW}awk is not installed. Bootstrapping...${NC}\n"
            BASE="true" bootstrap_binary "awk"
        fi
    fi
}

bootstrap
case $1 in
    run)
        run_from_cache "$2" "${@:3}"
        ;;
    install)
        install_binary "$2"
        ;;
    remove)
        remove_package "$2"
        ;;
    search)
        fSearch "$2"
        ;;
    info)
        show_package_info "$2"
        ;;
    list)
        list_packages
        ;;
    tldr)
        run_from_cache tldr "${@:2}"
        ;;
    *)
        printf 'Usage: %s {run|install|remove|search|info|list|tldr} <PACKAGE_NAME>\n' "$0"
        exit 1
        ;;
esac

exit 0
